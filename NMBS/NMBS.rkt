#lang racket

(require "GUI.rkt"
         "a-d/graph/labeled/config.rkt"
         "a-d/graph-algorithms/undirected/bft-applications.rkt"
         compatibility/mlist)
(provide nmbs-adt)

(define (client-adt ip-address)
  (let ((started #f)
        (otp '())
        (ip-address  ip-address)) ;"localhost" om lokaal te runnen 

    (define-values (in out) (tcp-connect ip-address 50))

    (define (sendmsg msg)
      (when started
        (write msg out)
        (flush-output out)
        (set! started #f)))

    (define (clean-output!)
      (set! otp '()))

    (define (start!)
      (set! started #t))

    (define (tcp-loop)
      (thread (lambda ()
                (let ((output (read in)))
                  (set! otp output)
                  (sleep 1/2)             
                  (tcp-loop)))))

    (tcp-loop)

    (define (client-dispatch m)
      (cond ((eq? m 'send) sendmsg)
            ((eq? m 'started) started)
            ((eq? m 'otp) otp)
            ((eq? m 'otp-clean) (clean-output!))
            ((eq? m 'start!) (start!))))
    client-dispatch))


(define (nmbs-adt ip-address)
  (let* ((client (client-adt ip-address));specifieke ip adres voor raspberry pi
         (gui (make-gui))
         (mode ((gui 'mode) void))
         (mode-selected #f)
         (graph '())
         (free-loco 0)
         (tcp-connection "none")
         )

    (define (sendmsg msg) ;TCP
      ((client 'send) msg))

    (define (mymlist->list mlist) ;conversion of mutable list to list
      (let ((res '())) ;+ puts list in right order
        (mfor-each (lambda (el)
                     (set! res (cons (number->string el) res)))
                   mlist)
        res))

    (define (new-path! start dest)
      (mymlist->list(shortest-path graph start dest)))

    (define (loco-info)
      (when (not (eq? #f (send locos get-selection)))
        (let ((sel (number->string (send locos get-selection))))
          (sendmsg (vector "Loco-info" sel)))))

    (define locos ((gui 'locos) loco-info)) ;list-box object
  
    ((gui 'btn)  "Start" (lambda ()
                           (when mode-selected
                             (sendmsg "Start"))) (gui 'vp1))

    ((gui 'exit) (lambda ()
                   (sendmsg "Exit")
                   (exit)))
  
    ((gui 'btn) "Stop" (lambda ()
                         (set! mode-selected #f)
                         (sendmsg "Stop")) (gui 'vp1))

    (define (reset-field)
      (send (gui 'loco-id) set-value ""))

    (define (loco-data otp) ;om de data van de trein te vernieuwen
      (let* ((loco-id (vector-ref otp 1))
             (loco-pos (vector-ref otp 2))
             (loco-dest (vector-ref otp 3))
             (loco-speed (vector-ref otp 4))
             (id (string-append "Loco id: " loco-id "\n"))
             (pos (string-append  "Position: " loco-pos "\n"))
             (dest (string-append "Destination: " loco-dest "\n"))
             (speed (string-append "Speed: " loco-speed "\n"))
             (msg (string-append id pos dest speed)))
        msg))
    

    ((gui 'btn) "Add-loco" (lambda ()
                             (when (< free-loco 3)
                               (let ((loco-id (send (gui 'loco-id) get-value))
                                     (start (send (gui 'start-seg) get-string-selection))
                                     (prev (send (gui 'prev-seg) get-string-selection))
                                     (dest (send (gui 'dest) get-string-selection)))
                                 (when (non-empty-string? loco-id)
                                   (send locos set-string free-loco loco-id)
                                   (set! free-loco (+ free-loco 1))
                                   (sendmsg (vector "Add-loco" loco-id start prev dest))
                                   (reset-field)
                                   )))) (gui 'vp3))

    ((gui 'btn) "Delete-loco" (lambda ()
                                (let ((sel (send locos get-selection)))
                                  (set! free-loco sel)
                                  (send locos set-string sel "Empty")
                                  (sendmsg (vector "Delete-loco" (number->string sel)))
                                  ))
                (gui 'vp3))

    ((gui 'btn) "Confirm" (lambda ()
                            (let ((sel (send locos get-selection)))
                              (sendmsg (vector "Speed!" sel))
                              )) (gui 'vp4))


    ((gui 'btn) "Invert" (lambda ()
                           (let ((sel (send locos get-selection)))
                             (sendmsg (vector "Invert!" sel)))) (gui 'vp4))
    
    (define (run-simulator)
      (let ((msg (send mode get-item-label (send mode get-selection))))
        (set! mode-selected #t)
        (sendmsg (vector "Mode" msg))))

    ((gui 'btn) "Confirm mode" run-simulator (gui 'vp2))

    (define (load-setup setup)
      (let ((start (gui 'start-seg))
            (prev (gui 'prev-seg))
            (dest (gui 'dest)))
        (send start clear)
        (send prev clear)
        (send dest clear)
        (for-each (lambda (block)
                    (send start append block)
                    (send prev append block)
                    (send dest append block))
                  setup)))

   

    (define (load-harware-setup g) ;laad hardware setup in een graf
      
      (define 1-1 13)
      (define 1-2 14)
      (define 1-3 15)
      (define 1-4 17)
      (define 1-5 18)
      (define 1-6 19)
      (define 1-7 21)
      (define 1-8 22)
      (define 2-1 29)
      (define 2-2 30)
      (define 2-3 31)
      (define 2-4 32)
      (define 2-5 33)
      (define 2-6 34)
      (define 2-7 35)
      (define 2-8 36)
      

      (add-directed-edge! g 1-2 9 1)
      (add-directed-edge! g 24 1-2 1)
      (add-directed-edge! g 2-3 11 1)
      (add-directed-edge! g 27 1-2 1)
      (add-directed-edge! g 1-3 2-4 1)
      (add-directed-edge! g 1-3 1-4 1)
      (add-directed-edge! g 1-4 26 1)
      (add-directed-edge! g 26 1-1 1)
      (add-directed-edge! g 28 1-7 1)
      (add-directed-edge! g 10 1-1 1)
      (add-directed-edge! g 1-1 12 1)
      (add-edge! g 16 2-8 1)
      (add-directed-edge! g 16 12 1)
      (add-directed-edge! g 12 2-4 1)
      (add-directed-edge! g 2-3 5 1)
      (add-directed-edge! g 23 24 1)
      (add-directed-edge! g 2-4 23 1)
      (add-directed-edge! g 6 2-4 1)
      (add-directed-edge! g 2-4 20 1)
      (add-edge! g 20 1-5 1)
      (add-edge! g 1-5 2-4 1)
      (add-edge! g 1-4 1-5 1)
      (add-directed-edge! g 1-6 6 1)
      (add-directed-edge! g 5 1-6 1)
      (add-edge! g 1-7 1-6 1)
      (add-directed-edge! g 7 1-8 1)
      (add-directed-edge! g 1-8 25 1)
      (add-directed-edge! g 25 2 1)
      (add-directed-edge! g 25 6 2)
      (add-directed-edge! g 1 2-1 1)
      (add-directed-edge! g 2-1 2 1)
      (add-directed-edge! g 3 2-2 1)
      (add-directed-edge! g 2-2 1 1)
      (add-directed-edge! g 2-5 1 1)
      (add-directed-edge! g 8 4 1)
      (add-directed-edge! g 4 2-6 1)
      (add-directed-edge! g 2-6 1 1)
      (add-directed-edge! g 2-7 1 1)
      (add-directed-edge! g 27 1-3 2)
      (add-directed-edge! g 26 27 2)
      (add-directed-edge! g 28 1-4 2)
      (add-directed-edge! g 9 2-4 2)
      (add-directed-edge! g 9 12 1)
      (add-directed-edge! g 11 10 2)
      (add-directed-edge! g 11 1-2 1)
      (add-directed-edge! g 10 16 2)
      (add-directed-edge! g 16 2-8 2)
      (add-directed-edge! g 12 2-3 2)
      (add-directed-edge! g 24 1-3 2)
      (add-directed-edge! g 23 11 2)
      (add-directed-edge! g 20 5 2)
      (add-directed-edge! g 6 2-3 2)
      (add-directed-edge! g 5 7 2)
      (add-directed-edge! g 7 1 2)
      (add-directed-edge! g 2 3 2)
      (add-directed-edge! g 2 6 1)
      (add-directed-edge! g 3 8 2)
      (add-directed-edge! g 8 2-5 2)
      (add-directed-edge! g 4 2-7 2)
      (add-directed-edge! g 1 1-8 2)
      (add-edge! g 5 6 2)
      (add-directed-edge! g 7 2 2)
      (add-directed-edge! g 2-7 2 1)
      (add-directed-edge! g 2-6 2 1)
      (add-directed-edge! g 2-5 2 1)
      (add-directed-edge! g 2-2 2 1))

    (define (load-straight-setup g)
      (add-directed-edge! g 0 5 1)
      (add-directed-edge! g 5 1 1)
      (add-directed-edge! g 1 2 1)
      (add-directed-edge! g 5 3 2)
      (add-directed-edge! g 3 4 1))

    (define (setup-loop g)
      (add-edge! g 0 1 1)
      (add-directed-edge! g 0 10 1)
      (add-edge! g 1 2 1)
      (add-edge! g 2 3 1)
      (add-directed-edge! g 3 9 1)      
      (add-edge! g 4 5 1)
      (add-edge! g 4 9 1)
      (add-directed-edge! g 4 3 1)
      (add-edge! g 10 5 1)
      (add-directed-edge! g 5 0 1)
      (add-directed-edge! g 9 11 2)
      (add-directed-edge! g 10 6 2)
      (add-directed-edge! g 11 6 1)
      (add-directed-edge! g 11 7 2)
      (add-edge! g 7 8 1)
      (add-directed-edge! g 7 3 1)
      (add-directed-edge! g 6 0 1)
      (add-directed-edge! g 6 3 1)
      )
    

    (define (ready-path path) ;given a path, will set path ready, i.e.
      (let loop ((res '())
                 (p path))
        (if (and (not (null? p)) ;set each switch on the right position & reserve switches
                 (not (null? (cdr p))))
            (let* ((curr (car p))
                   (next (cadr p)))
              (let ((edge-label (edge-label graph (string->number curr)
                                            (string->number next))))
                (cond  ((= 2 edge-label)
                        (let ((edge (list "2" curr next)))
                          (set! res (cons edge res))
                          (loop res (cdr p))))
                       ((= 1 edge-label)
                        (let ((edge (list "1" curr next)))
                          (set! res (cons edge res))
                          (loop res (cdr p))))
                       (else (loop res (cdr p))))))
            res)
        ))
              

    (define (check-otp)
      (let ((output (client 'otp)))
        (when (not (null? output))
          (if (vector? output)
              (let ((msg (vector-ref output 0)))
                (cond ((string=? msg "Loco-data")
                       (let ((data (loco-data output)))
                         ((gui 'pos!) data)))
                      ((string=? msg "Path")
                       (let* ((start (string->number (vector-ref output 1)))
                              (dest (string->number (vector-ref output 2)))
                              (path (new-path! start dest))
                              (edges (ready-path path))
                              (slot (vector-ref output 3)))
                         (sendmsg (vector "Path" path edges slot))
                         ))
                      ((string=? msg "load-hardware")
                       (load-setup (vector-ref output 1))
                       (let ((g (new #f 37))) ;adj list repr
                         (set! graph g)
                         (load-harware-setup graph)
                         ))
                      ((string=? msg "load-loop-setup")
                       (let ((g (new #f 12))) ;adj list repr
                         (set! graph g)
                         (load-setup (vector-ref output 1))
                         (setup-loop graph)
                         ))
                      ((string=? msg "load-straight-setup")
                       (let ((g (new #t 6))) ;adj list repr
                         (set! graph g)
                         (load-setup (vector-ref output 1))
                         (load-straight-setup graph)
                         ))
                      ((string=? msg "New-path!")
                       (let* ((loco (vector-ref output 1))
                              (start (string->number (vector-ref output 2)))
                              (dest (string->number (vector-ref output 3)))
                              (path (new-path! start dest))
                              (edges (ready-path path)))                    
                         (sendmsg (vector "New-Path!" loco path edges))))
                      ((string=? msg "TCP-test")
                       (let ((state (vector-ref output 1)))
                         (set! tcp-connection state)
                         ))
                      ))
              (cond ((eq? output eof)
                     (sendmsg "close-tcp")
                     (exit))
                    ((string=? output "Reset")
                     (send locos clear)
                     (send locos set (list "Empty"
                                           "Empty"
                                           "Empty")))
                    )))))


    (define (loop)
      (thread
       (lambda ()
         (client 'start!) ;start de client
         (check-otp) ;abstractie van tcp-loop
         (client 'otp-clean) ;clean de buffer na het checken
         (sleep 1/2)
         (loop))))

    (define (start-nmbs)
      (loop))
    
    (define (nmbs-dispatch m)
      (cond ((eq? m 'start) (start-nmbs))
            ((eq? m 'test) (gui 'mode))
            ((eq? m 'gui) gui)
            ((eq? m 'otp) (client 'otp))
            ((eq? m 'newp) new-path!)
            ((eq? m 'mode) (send mode get-item-label (send mode get-selection)))
            ((eq? m 'rb) mode) ;radio box van GUI
            ((eq? m 'send) sendmsg)
            ((eq? m 'c) client)
            ((eq? m 'tcp) tcp-connection)
            ))
    nmbs-dispatch))

;(define nmbs (nmbs-adt))